import {
  ASTNode,
  FieldNode,
  FragmentDefinitionNode,
  FragmentSpreadNode,
  OperationDefinitionNode,
  SelectionSetNode
} from 'graphql';

import { visit, BREAK } from 'graphql/language/visitor';

import {
  ProtoObjType,
  FragsType,
  ArgsObjType,
  FieldArgsType,
  GQLNodeWithDirectivesType,
  ValidArgumentNodeType,
  FieldsValuesType,
  FieldsObjectType
} from '../types';

/**
 * Traverses the abstract syntax tree depth-first to determine which operations types are 'unQuellable' along the AST.
 * @param {Object} AST - Abstract syntax tree generated by GraphQL library.
 * @returns {Object} Object containing operation type is 'unQuellable' and prototype object.
 */
export default function determineType(AST: ASTNode): {
  operationType: string;
  proto: ProtoObjType;
  fieldNames: string[];
} {

  // Initialize an array to keep track of the field names in the AST.
  let fieldNames: string[] = [];

  // Initialize a prototype object which will be populated with information extracted from the AST.
  const proto: ProtoObjType = {};

  // Initialize a frags object to keep track of the fragments in the query.
  const frags: FragsType = {};

  // Initialize an arguments object to store the arguments in the current node.
  const argsObj: ArgsObjType = {};

  // Declare a targetObj which will be used to point to prototype when iterating through Field nodes 
  // and to point to frags when iterating through Fragment Definition nodes.
  let targetObj: ProtoObjType | FragsType;

  // Initialize operationType which will hold the type of operation ('query', 'mutation', 'subscription', etc.).
  let operationType = '';

  // Initialize a stack to keep track of nodes while traversing the AST in depth-first order.
  const stack: string[] = [];

  // Initialize variable to keep track of depth of selection set in the AST.
  let selectionSetDepth = 0;

  // Initialize an object to keep track of the id, type, alias, and args for the fields.
  // The field arguments object will eventually be merged with the prototype object.
  const fieldArgs: FieldArgsType = {};

  // Initialize a variable to keep track of depth in the AST.
  let depth = 0;

  /**
   * visit is a utility provided in the graphql-JS library. It performs a depth-first traversal of the abstract 
   * syntax tree, invoking a callback when each SelectionSet node is entered. That function builds the prototype.
   * Invokes a callback when entering and leaving Field node to keep track of nodes with stack.
   * Find documentation at: https://graphql.org/graphql-js/language/#visit
   */
  visit(AST, {
    // The enter function will be triggered upon entering each node in the traversal.
    enter(node: ASTNode) {
      // Quell cannot cache directives, so we need to return as unQuellable if the node has directives.
      if ((node as GQLNodeWithDirectivesType)?.directives) {
        if ((node as GQLNodeWithDirectivesType)?.directives?.length ?? 0 > 0) {
          operationType = 'unQuellable';
          // Return BREAK to break out of the current traversal branch.
          return BREAK;
        }
      }
    },

    // If the current node is of type OperationDefinition, this function will be triggered upon entering it.
    // It checks the type of operation being performed.
    OperationDefinition(node: OperationDefinitionNode) {
      targetObj = proto;
      // Quell cannot cache subscriptions, so we need to return as unQuellable if the type is subscription.
      operationType = node.operation;
      if (operationType === 'subscription') {
        operationType = 'unQuellable';
        // Return BREAK to break out of the current traversal branch.
        return BREAK;
      }
    },

    // If the current node is of type FragmentDefinition, this function will be triggered upon entering it.
    FragmentDefinition: {
      enter(node: FragmentDefinitionNode) {
        // Get the name of the fragment.
        const fragName: string = node.name.value;
        // Add the fragment name to the stack.
        stack.push(fragName);

        // Add the fragment name as a key in target object (which will be frags while inside the loop below), initialized to an empty object.
        targetObj = frags;
        targetObj[fragName] = {};

        // Loop through the selections in the selection set for the current FragmentDefinition node in order to extract the fields in the fragment.
        for (let i = 0; i < node.selectionSet.selections.length; i++) {
          // Skip nodes of type 'InlineFragment' as they don't have a 'name' property.
          if (node.selectionSet.selections[i].kind !== 'InlineFragment') {
            // Add base-level field names in the fragment to the frags (aka target) object.
            (targetObj as FragsType)[fragName][
              (node.selectionSet.selections[i] as | FieldNode | FragmentSpreadNode).name.value
            ] = true;
          }
        }
      },

      // If the current node is of type FragmentDefinition, this function will be triggered after visiting it and all of its children.
      leave() {
        // Pop stacks to keep track of depth-first parsing path.
        stack.pop();
      }
    },

    Field: {
      // If the current node is of type Field, this function will be triggered upon entering it.
      enter(node: FieldNode) {
        // Increment depth if the node has a selection set.
        if (node.selectionSet) depth++;

        // Return introspection queries as 'unQuellable' to prevent caching.
        // "__keyname" syntax is later used for Quell's field-specific options, though this does not create collision with introspection.

        // Fields with names including '__' are excluded from caching.
        if (node.name.value.includes('__')) {
          operationType = 'unQuellable';
          // Return BREAK to break out of the current traversal branch.
          return BREAK;
        }

        // Loop through the field's arguments.
        if (node.arguments) {
          node.arguments.forEach((arg) => {
            const key: string = arg.name.value;

            // Quell cannot cache queries with variables, so we need to return unQuellable if the query has variables.
            if (arg.value.kind === 'Variable' && operationType === 'query') {
              operationType = 'unQuellable';
              // Return BREAK to break out of the current traversal branch.
              return BREAK;
            }

            /**
             * In the next step, we get the value from the argument node's value node. This assumes that the value 
             * node has a 'value' property. If the 'kind' of the value node is ObjectValue, ListValue, NullValue, 
             * or ListValue then the value node will not have a 'value' property, so we must first check that
             * the 'kind' does not match any of those types.
             */
            if (
              arg.value.kind === 'NullValue' || arg.value.kind === 'ObjectValue' || arg.value.kind === 'ListValue') {
              operationType = 'unQuellable';
              // Return BREAK to break out of the current traversal branch.
              return BREAK;
            }

            // Assign argument values to argsObj (key will be argument name, value will be argument value),
            // skipping field-specific options ('__') provided as arguments.
            if (!key.includes('__')) {
              argsObj[key] = (arg.value as ValidArgumentNodeType).value;
            }
          });
        }

        // Set the fieldType equal to either the field's alias or the field's name.
        const fieldType: string = node.alias
          ? node.alias.value
          : node.name.value;

        // Add the field type to the stack to keep track of depth-first parsing path.
        stack.push(fieldType);

        // If the field has a name and is at depth greater than 1, add it to fieldNames.
        if ((node.name && node.name.value && depth > 1 && node.selectionSet) || (selectionSetDepth === 1 && depth === 1)) {
          fieldNames.push(node.name.value);
        }
      },

      // If the current node is of type 'Field', this function will be triggered after visiting it and all of its children.
      leave(node: FieldNode) {
        // Decrement depth if the node has a selection set.
        if (node.selectionSet) depth--;

        // Pop stacks to keep track of depth-first parsing path.
        stack.pop();
      }
    },

    SelectionSet: {
      // If the current node is of type SelectionSet, this function will be triggered upon entering it.
      // The selection sets contain all of the sub-fields. Iterate through the sub-fields to construct fieldsObject
      enter(
        node: SelectionSetNode,
        key: string | number | undefined,
        parent: ASTNode | readonly ASTNode[] | undefined,
        path: readonly (string | number)[],
        ancestors: readonly (ASTNode | readonly ASTNode[])[]
      ) {
        selectionSetDepth++;

        /**
         * Exclude SelectionSet nodes whose parents are not of the kind 'Field' 
         * to exclude nodes that do not contain information about queried fields.
         */
        if (
          parent && // parent is not undefined
          !Array.isArray(parent) && // parent is not readonly ASTNode[]
          (parent as ASTNode).kind === 'Field' // can now safely assume that parent will have 'kind' property
        ) {
          // Create a 'fieldsValues' object to collect fields as we loop through the selections.
          const fieldsValues: FieldsValuesType = {};

          for (const field of node.selections) {
            /**
             * If the current selection in the selections array is not a nested object
             * (i.e., does not have a SelectionSet), set its value in 'fieldsValues' to true.
             * Note: InlineFragmentNode (one of the possible types for SelectionNode) does not
             * have a 'name' property, so we skip nodes with that type.
             * Furthermore, FragmentSpreadNodes never have a selection set property.
            */
            if (
              field.kind !== 'InlineFragment' &&
              (field.kind === 'FragmentSpread' || !field.selectionSet)
            )
              fieldsValues[field.name.value] = true;
          }

          // If the request does not include 'id' and the current node is not a fragment,
          // mark the operation as 'unQuellable' as the query will not be included in the cache.
          if (
            !Object.prototype.hasOwnProperty.call(fieldsValues, 'id') &&
            !Object.prototype.hasOwnProperty.call(fieldsValues, '_id') &&
            !Object.prototype.hasOwnProperty.call(fieldsValues, 'ID') &&
            !Object.prototype.hasOwnProperty.call(fieldsValues, 'Id')
          ) {
            operationType = 'unQuellable';
            // Return 'BREAK' to break out of the current traversal branch.
            return BREAK;
          }

          // Place current fieldArgs object onto fieldsObject so it gets passed along to prototype.
          // The fieldArgs contains arguments, aliases, etc.
          const fieldsObject: FieldsObjectType = {
            ...fieldsValues,
            ...fieldArgs[stack[stack.length - 1]]
          };

          // Loop through the stack to get the correct path in 'proto' for the temporary object.
          // This mutation updates the original prototype object with values from the temporary object.
          stack.reduce(
            (prev: ProtoObjType, curr: string, index: number): ProtoObjType => {
              // If it's the last item in the path, set the value.
              if (index + 1 === stack.length) prev[curr] = { ...fieldsObject };
              return prev[curr] as ProtoObjType;
            },
            targetObj
          );
        }
      },
      leave() {
        // Decrement the depth of the selection set as we leave the node.
        selectionSetDepth--;
      }
    }
  });

  fieldNames = [...new Set(fieldNames)];
  return { operationType, proto, fieldNames };
}
